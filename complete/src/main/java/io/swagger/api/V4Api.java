/**
 * NOTE: This class is auto generated by the swagger code generator program (3.0.22).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package io.swagger.api;

import io.swagger.model.AccessTokenResponse;
import io.swagger.model.AssetResponse;
import io.swagger.model.AuthCodeResponse;
import io.swagger.model.AuthorizeResponse;
import io.swagger.model.BearerToken;
import io.swagger.model.DecoupledAuthRequestV4;
import io.swagger.model.ErrorResponse;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.bind.annotation.CookieValue;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.SpringCodegen", date = "2020-10-24T19:28:18.999418-04:00[America/New_York]")
@Api(value = "v4", description = "the v4 API")
public interface V4Api {

    @ApiOperation(value = "Redirect - Token Exchange", nickname = "accessTokenUsingPOST2", notes = "", response = BearerToken.class, authorizations = {
        @Authorization(value = "DecoupledAuth", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            }),
@Authorization(value = "OAuth2", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            })    }, tags={ "Authorization", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "OK", response = BearerToken.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized with failure code: * error.apikey.missing = Missing API key. This operation requires API key, but it was missing. * error.token = Unspecified error with supplied token. * error.token.invalid = Missing access token or token did not authorized requested operation. This operation requires valid access token, but it was missing. * error.token.expired = Access token has expired.", response = ErrorResponse.class),
        @ApiResponse(code = 403, message = "Forbidden with failure code: * error.resource.denied = Requested resource is not authorized by access token.", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Resource not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/v4/authorize/token",
        produces = { "application/json" }, 
        consumes = { "application/x-www-form-urlencoded" },
        method = RequestMethod.POST)
    ResponseEntity<BearerToken> accessTokenUsingPOST2(@ApiParam(value = "Standard http header element for date and time. HTTP headers are represented as RFC 7231 Full Dates. example date: Wed, 24 Apr 2019 14:00:37 EEST" ,required=true) @RequestHeader(value="Date", required=true) String date
,@ApiParam(value = "The Digest Header header as defined in [RFC3230] contains a Hash of the message body. The only hash algorithms that may be used to calculate the Digest within the context of this specification are SHA-256 and SHA-512 as defined in [RFC5843].\"," ,required=true) @RequestHeader(value="Digest", required=true) String digest
,@ApiParam(value = "A signature of request by the TPP on application level. The process of signing a request is described in 'Signing HTTP Messages' RFC draft version 10 (https://tools.ietf.org/html/draft-cavage-http-signatures-10). The request signature needs to be sent in the 'Signature' HTTP header as described in the RFC. Additional requirements from Nordea   - The only allowed algorithm is RSA-SHA256  - The key size for the used RSA key pair has to be at least 2048 bit  - The keyId is the clientId of your application originating from the Nordea Developer Portal  - We require the following headers to be used in the signature  * GET request: (request-target) host date  * PUT and POST request: (request-target) host date content-type digest .  * The request-target is a combination of the HTTP action verb and the request URI path." ,required=true) @RequestHeader(value="Signature", required=true) String signature
,@ApiParam(value = "Id of the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Id", required=true) String xIBMClientId
,@ApiParam(value = "Secret password generated for the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Secret", required=true) String xIBMClientSecret
,@ApiParam(value = "End user (i.e. PSU) agent information, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Agent", required=false) String xNordeaOriginatingUserAgent
,@ApiParam(value = "End user (i.e. PSU) IP address, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Ip", required=false) String xNordeaOriginatingUserIp
);


    @ApiOperation(value = "Redirect Access Authorization", nickname = "authorizationV4FiDkNo", notes = "", tags={ "Authorization", })
    @ApiResponses(value = { 
        @ApiResponse(code = 302, message = "Redirect to OAuth provider"),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized with failure code: * error.apikey.missing = Missing API key. This operation requires API key, but it was missing. * error.token = Unspecified error with supplied token. * error.token.invalid = Missing access token or token did not authorized requested operation. This operation requires valid access token, but it was missing. * error.token.expired = Access token has expired.", response = ErrorResponse.class),
        @ApiResponse(code = 403, message = "Forbidden with failure code: * error.resource.denied = Requested resource is not authorized by access token.", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Resource not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/v4/authorize",
        produces = { "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<Void> authorizationV4FiDkNo(@NotNull @ApiParam(value = "client id issued to the TPP via the Developer Portal for the App in use", required = true) @Valid @RequestParam(value = "client_id", required = true) String clientId
,@NotNull @ApiParam(value = "Country is a mandatory parameter with possible values FI, DK or NO", required = true, allowableValues = "FI, DK, NO") @Valid @RequestParam(value = "country", required = true) String country
,@NotNull @ApiParam(value = "Duration of access authorization in minutes. range: 1 to 129600 minutes (90 days)", required = true) @Valid @RequestParam(value = "duration", required = true) Integer duration
,@NotNull @ApiParam(value = "Redirect URI you used when this application was registered with Nordea.", required = true) @Valid @RequestParam(value = "redirect_uri", required = true) String redirectUri
,@NotNull @ApiParam(value = "scope is a list of one or more of the scopes described below:  AIS scopes: - ACCOUNTS_BASIC (note: Must always be present at a minimum, when requesting ACCOUNTS_* scopes) - ACCOUNTS_BALANCES - ACCOUNTS_DETAILS - ACCOUNTS_TRANSACTIONS  PIS scope: - PAYMENTS_MULTIPLE", required = true) @Valid @RequestParam(value = "scope", required = true) List<String> scope
,@NotNull @ApiParam(value = "The OAuth2 state parameter", required = true) @Valid @RequestParam(value = "state", required = true) String state
,@ApiParam(value = "End user (i.e. PSU) agent information, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Agent", required=false) String xNordeaOriginatingUserAgent
,@ApiParam(value = "End user (i.e. PSU) IP address, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Ip", required=false) String xNordeaOriginatingUserIp
,@ApiParam(value = "Optional list of payment accounts for which the PSU has agreed access with the TPP. If not provided, PSU will select payment account(s) in the Nordea UI. Special case: passing 'ALL' results in the PSU agreeing access to all of their Nordea payment accounts.") @Valid @RequestParam(value = "account_list", required = false) List<String> accountList
,@ApiParam(value = "Parameter with possible values: NEMID_2F (DK only: NemID with username, password and OTC/NMAS), BANKID_NO (NO only: BankID Norway), BANKIDM_NO (NO only: Mobile BankID Norway)", allowableValues = "NEMID_2F, BANKID_NO, BANKIDM_NO") @Valid @RequestParam(value = "authentication_method", required = false) String authenticationMethod
,@ApiParam(value = "If country is FI, the default language is \"fi\", if country is DK, the default language is \"da\", if country is NO, the default language is \"no\"", allowableValues = "fi, da, sv, en, no") @Valid @RequestParam(value = "language", required = false) String language
,@ApiParam(value = "Optional if authentication_method is provided; not possible without authentication_method. Enables the Client to further streamline the authentication flow user experience.  If authentication_method=NEMID_2F, no login_hint is possible  If authentication_method=BANKID_NO, login_hint can be user ID  If authentication_method=BANKIDM_NO, login hint can be mobile number and date of birth, separated by ':'") @Valid @RequestParam(value = "login_hint", required = false) String loginHint
,@ApiParam(value = "Maximum transaction history in months. Optional if ACCOUNTS_TRANSACTIONS scope is requested. Default=12 months. range: 1 to 12 months") @Valid @RequestParam(value = "max_tx_history", required = false) Integer maxTxHistory
);


    @ApiOperation(value = "Decoupled Access Authorization (Sweden only)", nickname = "authorizationV4Se", notes = "", response = AuthorizeResponse.class, authorizations = {
        @Authorization(value = "DecoupledAuth", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            }),
@Authorization(value = "OAuth2", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            })    }, tags={ "Decoupled Authorization", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Authorize", response = AuthorizeResponse.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized with failure code: * error.apikey.missing = Missing API key. This operation requires API key, but it was missing. * error.token = Unspecified error with supplied token. * error.token.invalid = Missing access token or token did not authorized requested operation. This operation requires valid access token, but it was missing. * error.token.expired = Access token has expired.", response = ErrorResponse.class),
        @ApiResponse(code = 403, message = "Forbidden with failure code: * error.resource.denied = Requested resource is not authorized by access token.", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Resource not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/v4/authorize-decoupled",
        produces = { "application/json" }, 
        consumes = { "application/json" },
        method = RequestMethod.POST)
    ResponseEntity<AuthorizeResponse> authorizationV4Se(@ApiParam(value = "Standard http header element for date and time. HTTP headers are represented as RFC 7231 Full Dates. example date: Wed, 24 Apr 2019 14:00:37 EEST" ,required=true) @RequestHeader(value="Date", required=true) String date
,@ApiParam(value = "The Digest Header header as defined in [RFC3230] contains a Hash of the message body. The only hash algorithms that may be used to calculate the Digest within the context of this specification are SHA-256 and SHA-512 as defined in [RFC5843].\"," ,required=true) @RequestHeader(value="Digest", required=true) String digest
,@ApiParam(value = "A signature of request by the TPP on application level. The process of signing a request is described in 'Signing HTTP Messages' RFC draft version 10 (https://tools.ietf.org/html/draft-cavage-http-signatures-10). The request signature needs to be sent in the 'Signature' HTTP header as described in the RFC. Additional requirements from Nordea   - The only allowed algorithm is RSA-SHA256  - The key size for the used RSA key pair has to be at least 2048 bit  - The keyId is the clientId of your application originating from the Nordea Developer Portal  - We require the following headers to be used in the signature  * GET request: (request-target) host date  * PUT and POST request: (request-target) host date content-type digest .  * The request-target is a combination of the HTTP action verb and the request URI path." ,required=true) @RequestHeader(value="Signature", required=true) String signature
,@ApiParam(value = "Id of the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Id", required=true) String xIBMClientId
,@ApiParam(value = "Secret password generated for the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Secret", required=true) String xIBMClientSecret
,@ApiParam(value = "Request for authorization" ,required=true )  @Valid @RequestBody DecoupledAuthRequestV4 body
,@ApiParam(value = "End user (i.e. PSU) agent information, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Agent", required=false) String xNordeaOriginatingUserAgent
,@ApiParam(value = "End user (i.e. PSU) IP address, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Ip", required=false) String xNordeaOriginatingUserIp
);


    @ApiOperation(value = "Get user assets", nickname = "getAssetsUsingGET2", notes = "", response = AssetResponse.class, authorizations = {
        @Authorization(value = "DecoupledAuth", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            }),
@Authorization(value = "OAuth2", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            })    }, tags={ "Assets", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "OK", response = AssetResponse.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized with failure code: * error.apikey.missing = Missing API key. This operation requires API key, but it was missing. * error.token = Unspecified error with supplied token. * error.token.invalid = Missing access token or token did not authorized requested operation. This operation requires valid access token, but it was missing. * error.token.expired = Access token has expired.", response = ErrorResponse.class),
        @ApiResponse(code = 403, message = "Forbidden with failure code: * error.resource.denied = Requested resource is not authorized by access token.", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Resource not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/v4/assets",
        produces = { "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<AssetResponse> getAssetsUsingGET2(@ApiParam(value = "Standard http header element for date and time. HTTP headers are represented as RFC 7231 Full Dates. example date: Wed, 24 Apr 2019 14:00:37 EEST" ,required=true) @RequestHeader(value="Date", required=true) String date
,@ApiParam(value = "A signature of request by the TPP on application level. The process of signing a request is described in 'Signing HTTP Messages' RFC draft version 10 (https://tools.ietf.org/html/draft-cavage-http-signatures-10). The request signature needs to be sent in the 'Signature' HTTP header as described in the RFC. Additional requirements from Nordea   - The only allowed algorithm is RSA-SHA256  - The key size for the used RSA key pair has to be at least 2048 bit  - The keyId is the clientId of your application originating from the Nordea Developer Portal  - We require the following headers to be used in the signature  * GET request: (request-target) host date  * PUT and POST request: (request-target) host date content-type digest .  * The request-target is a combination of the HTTP action verb and the request URI path." ,required=true) @RequestHeader(value="Signature", required=true) String signature
,@ApiParam(value = "Id of the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Id", required=true) String xIBMClientId
,@ApiParam(value = "Secret password generated for the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Secret", required=true) String xIBMClientSecret
,@ApiParam(value = "End user (i.e. PSU) agent information, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Agent", required=false) String xNordeaOriginatingUserAgent
,@ApiParam(value = "End user (i.e. PSU) IP address, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Ip", required=false) String xNordeaOriginatingUserIp
);


    @ApiOperation(value = "Polling for Auth Code (Sweden only)", nickname = "getStatusUsingGET2", notes = "", response = AuthCodeResponse.class, authorizations = {
        @Authorization(value = "DecoupledAuth", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            }),
@Authorization(value = "OAuth2", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            })    }, tags={ "Decoupled Authorization", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Exchange TPP token for authorization code", response = AuthCodeResponse.class),
        @ApiResponse(code = 304, message = "Waiting for customer"),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized with failure code: * error.apikey.missing = Missing API key. This operation requires API key, but it was missing. * error.token = Unspecified error with supplied token. * error.token.invalid = Missing access token or token did not authorized requested operation. This operation requires valid access token, but it was missing. * error.token.expired = Access token has expired.", response = ErrorResponse.class),
        @ApiResponse(code = 403, message = "TPP token is expired or invalid", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Resource not found", response = ErrorResponse.class),
        @ApiResponse(code = 408, message = "The request has timed out") })
    @RequestMapping(value = "/v4/authorize-decoupled/{orderRef}",
        produces = { "application/json" }, 
        method = RequestMethod.GET)
    ResponseEntity<AuthCodeResponse> getStatusUsingGET2(@ApiParam(value = "Standard http header element for date and time. HTTP headers are represented as RFC 7231 Full Dates. example date: Wed, 24 Apr 2019 14:00:37 EEST" ,required=true) @RequestHeader(value="Date", required=true) String date
,@ApiParam(value = "A signature of request by the TPP on application level. The process of signing a request is described in 'Signing HTTP Messages' RFC draft version 10 (https://tools.ietf.org/html/draft-cavage-http-signatures-10). The request signature needs to be sent in the 'Signature' HTTP header as described in the RFC. Additional requirements from Nordea   - The only allowed algorithm is RSA-SHA256  - The key size for the used RSA key pair has to be at least 2048 bit  - The keyId is the clientId of your application originating from the Nordea Developer Portal  - We require the following headers to be used in the signature  * GET request: (request-target) host date  * PUT and POST request: (request-target) host date content-type digest .  * The request-target is a combination of the HTTP action verb and the request URI path." ,required=true) @RequestHeader(value="Signature", required=true) String signature
,@ApiParam(value = "Id of the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Id", required=true) String xIBMClientId
,@ApiParam(value = "Secret password generated for the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Secret", required=true) String xIBMClientSecret
,@ApiParam(value = "Order reference uuid",required=true) @PathVariable("orderRef") String orderRef
,@ApiParam(value = "End user (i.e. PSU) agent information, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Agent", required=false) String xNordeaOriginatingUserAgent
,@ApiParam(value = "End user (i.e. PSU) IP address, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Ip", required=false) String xNordeaOriginatingUserIp
);


    @ApiOperation(value = "Token Exchange (Sweden only)", nickname = "getTokenUsingPOST2", notes = "", response = AccessTokenResponse.class, authorizations = {
        @Authorization(value = "DecoupledAuth", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            }),
@Authorization(value = "OAuth2", scopes = { 
            @AuthorizationScope(scope = "ACCOUNTS_BASIC", description = "Account information"),
            @AuthorizationScope(scope = "ACCOUNTS_BALANCES", description = "Account information with balances"),
            @AuthorizationScope(scope = "ACCOUNTS_DETAILS", description = "Account information with details"),
            @AuthorizationScope(scope = "ACCOUNTS_TRANSACTIONS", description = "Account&#x27;s transactions"),
            @AuthorizationScope(scope = "PAYMENTS_MULTIPLE", description = "Payments Multiple")
            })    }, tags={ "Decoupled Authorization", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Exchange authorization code for a access_token", response = AccessTokenResponse.class),
        @ApiResponse(code = 400, message = "Bad Request", response = ErrorResponse.class),
        @ApiResponse(code = 401, message = "Unauthorized with failure code: * error.apikey.missing = Missing API key. This operation requires API key, but it was missing. * error.token = Unspecified error with supplied token. * error.token.invalid = Missing access token or token did not authorized requested operation. This operation requires valid access token, but it was missing. * error.token.expired = Access token has expired.", response = ErrorResponse.class),
        @ApiResponse(code = 403, message = "Forbidden with failure code: * error.resource.denied = Requested resource is not authorized by access token.", response = ErrorResponse.class),
        @ApiResponse(code = 404, message = "Resource not found", response = ErrorResponse.class) })
    @RequestMapping(value = "/v4/authorize-decoupled/token",
        produces = { "application/json" }, 
        consumes = { "application/x-www-form-urlencoded" },
        method = RequestMethod.POST)
    ResponseEntity<AccessTokenResponse> getTokenUsingPOST2(@ApiParam(value = "Standard http header element for date and time. HTTP headers are represented as RFC 7231 Full Dates. example date: Wed, 24 Apr 2019 14:00:37 EEST" ,required=true) @RequestHeader(value="Date", required=true) String date
,@ApiParam(value = "The Digest Header header as defined in [RFC3230] contains a Hash of the message body. The only hash algorithms that may be used to calculate the Digest within the context of this specification are SHA-256 and SHA-512 as defined in [RFC5843].\"," ,required=true) @RequestHeader(value="Digest", required=true) String digest
,@ApiParam(value = "A signature of request by the TPP on application level. The process of signing a request is described in 'Signing HTTP Messages' RFC draft version 10 (https://tools.ietf.org/html/draft-cavage-http-signatures-10). The request signature needs to be sent in the 'Signature' HTTP header as described in the RFC. Additional requirements from Nordea   - The only allowed algorithm is RSA-SHA256  - The key size for the used RSA key pair has to be at least 2048 bit  - The keyId is the clientId of your application originating from the Nordea Developer Portal  - We require the following headers to be used in the signature  * GET request: (request-target) host date  * PUT and POST request: (request-target) host date content-type digest .  * The request-target is a combination of the HTTP action verb and the request URI path." ,required=true) @RequestHeader(value="Signature", required=true) String signature
,@ApiParam(value = "Id of the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Id", required=true) String xIBMClientId
,@ApiParam(value = "Secret password generated for the Client" ,required=true) @RequestHeader(value="X-IBM-Client-Secret", required=true) String xIBMClientSecret
,@ApiParam(value = "End user (i.e. PSU) agent information, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Agent", required=false) String xNordeaOriginatingUserAgent
,@ApiParam(value = "End user (i.e. PSU) IP address, to be provided if TPP is in session with the PSU" ) @RequestHeader(value="X-Nordea-Originating-User-Ip", required=false) String xNordeaOriginatingUserIp
);

}

